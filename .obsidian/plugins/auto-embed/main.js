/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoEmbedPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/settings-tab.ts
var import_obsidian2 = require("obsidian");

// src/preview-embed-modal.ts
var import_obsidian = require("obsidian");
var PreviewEmbedModal = class extends import_obsidian.Modal {
  constructor(plugin, url, options) {
    super(plugin.app);
    this.plugin = plugin;
    this.url = url;
    this.options = options != null ? options : "";
  }
  createEmbed(contentEl) {
    const readingViewImg = createEl("img");
    readingViewImg.src = this.url;
    readingViewImg.alt = this.options;
    contentEl.appendChild(readingViewImg);
    return this.plugin.handleImage(readingViewImg);
  }
  onOpen() {
    const { contentEl } = this;
    this.titleEl.textContent = "Preview Embed";
    let currEmbed = null;
    new import_obsidian.Setting(contentEl).setName("Preview url").addText((text) => text.setValue(this.url).onChange((value) => {
      this.url = value;
      if (currEmbed)
        contentEl.removeChild(currEmbed);
      currEmbed = this.createEmbed(contentEl);
    }));
    new import_obsidian.Setting(contentEl).setName("Preview option").addText((text) => text.setValue(this.options).onChange((value) => {
      this.options = value;
      if (currEmbed)
        contentEl.removeChild(currEmbed);
      currEmbed = this.createEmbed(contentEl);
    }));
    contentEl.appendChild(createEl("h3", { text: "Embed" }));
    currEmbed = this.createEmbed(contentEl);
  }
};

// src/settings-tab.ts
var FallbackOptions = /* @__PURE__ */ ((FallbackOptions2) => {
  FallbackOptions2[FallbackOptions2["ShowErrorMessage"] = 0] = "ShowErrorMessage";
  FallbackOptions2[FallbackOptions2["EmbedLink"] = 1] = "EmbedLink";
  FallbackOptions2[FallbackOptions2["Hide"] = 2] = "Hide";
  return FallbackOptions2;
})(FallbackOptions || {});
var GoogleDocsViewOptions = /* @__PURE__ */ ((GoogleDocsViewOptions2) => {
  GoogleDocsViewOptions2[GoogleDocsViewOptions2["Preview"] = 0] = "Preview";
  GoogleDocsViewOptions2[GoogleDocsViewOptions2["EditMinimal"] = 1] = "EditMinimal";
  GoogleDocsViewOptions2[GoogleDocsViewOptions2["EditDefault"] = 2] = "EditDefault";
  return GoogleDocsViewOptions2;
})(GoogleDocsViewOptions || {});
var PreloadOptions = /* @__PURE__ */ ((PreloadOptions2) => {
  PreloadOptions2[PreloadOptions2["None"] = 0] = "None";
  PreloadOptions2[PreloadOptions2["Placeholder"] = 1] = "Placeholder";
  PreloadOptions2[PreloadOptions2["Placeholder_ClickToLoad"] = 2] = "Placeholder_ClickToLoad";
  return PreloadOptions2;
})(PreloadOptions || {});
var supportedWebsites = ["Twitter/X", "Imgur", "Reddit", "CodePen", "Google Docs", "SoundCloud", "Spotify", "Steam", "TikTok"];
var DEFAULT_SETTINGS = {
  darkMode: true,
  preloadOption: 1 /* Placeholder */,
  suggestEmbed: true,
  enabledWebsites: ResetEnabledWebsites(),
  // enabledWebsites: new Map(Object.values(SupportedWebsites).map(website => [
  //     website, 
  //     // Set excluded websites to false (by default), set other websites to true.
  //     (website !== SupportedWebsites.YouTube && website !== SupportedWebsites.Twitter),
  // ])),
  googleDocsViewOption: 0 /* Preview */,
  fallbackOptions: 1 /* EmbedLink */,
  fallbackWidth: "100%",
  fallbackHeight: "500px",
  fallbackDefaultLink: "Link",
  fallbackAutoTitle: true,
  showAdvancedSettings: false,
  debug: false
};
var AutoEmbedSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    const plugin = this.plugin;
    const settings = this.plugin.settings;
    containerEl.empty();
    function ValidateSettings(setting, plugin2) {
      if (setting.enabledWebsites && Object.keys(setting.enabledWebsites).length > 0) {
        const newWebsites = supportedWebsites.filter((website) => setting.enabledWebsites[website] === void 0);
        if (newWebsites.length > 0) {
          newWebsites.forEach((website) => setting.enabledWebsites[website] = true);
          plugin2.saveSettings();
        }
      } else {
        console.log("No enabled websites setting found. Adding all");
        setting.enabledWebsites = ResetEnabledWebsites();
        plugin2.saveSettings();
      }
    }
    ValidateSettings(settings, plugin);
    function EnumToRecord(e) {
      const recordOutput = {};
      for (const option in e) {
        if (!isNaN(Number(option)))
          continue;
        const displayText = option.replace(/([a-z0-9])([A-Z])/g, (match, p1, p2) => `${p1} ${p2.toLowerCase()}`);
        recordOutput[option] = displayText;
      }
      return recordOutput;
    }
    function AddPadding(setting, addBottomBorder = false) {
      setting.settingEl.style.paddingLeft = "2em";
      setting.settingEl.style.borderLeft = "1px solid var(--background-modifier-border)";
      if (addBottomBorder)
        setting.settingEl.style.borderBottom = "1px solid var(--background-modifier-border)";
    }
    const previewTooltip = "Opens a modal (small window) to test with links with your settings";
    new import_obsidian2.Setting(containerEl).setName("Preview Embed").setTooltip(previewTooltip).addButton((btn) => btn.setButtonText("Preview").setTooltip(previewTooltip).onClick(() => {
      const modal = new PreviewEmbedModal(plugin, "https://x.com/obsdmd/status/1739667211462316449");
      modal.open();
    }));
    new import_obsidian2.Setting(containerEl).setName("Dark mode").setDesc("If the website has an option for it, sets the default theme for embeds.").addToggle(
      (toggle) => toggle.setValue(settings.darkMode).onChange(async (value) => {
        settings.darkMode = value;
        await this.plugin.saveSettings();
      })
    );
    const preloadOptions = EnumToRecord(PreloadOptions);
    Object.entries(preloadOptions).forEach(([key, value]) => {
      preloadOptions[key] = value.replace("_", " + ");
    });
    new import_obsidian2.Setting(containerEl).setName("Preload options").setDesc("Choose how the embed behaves before loading.").addDropdown(
      (dropdown) => dropdown.addOptions(preloadOptions).setValue(PreloadOptions[settings.preloadOption]).onChange(async (value) => {
        settings.preloadOption = PreloadOptions[value];
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Suggest embed").setDesc("If you are pasting a link, suggest to embed it.").addToggle(
      (toggle) => toggle.setValue(settings.suggestEmbed).onChange(async (value) => {
        settings.suggestEmbed = value;
        if (settings.suggestEmbed)
          plugin.registerSuggest();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Supported website").setHeading().setDesc("YouTube & Twitter/X is supported by Obsidian natively so it's off by default.");
    for (const website in settings.enabledWebsites) {
      const websiteSetting = new import_obsidian2.Setting(containerEl).setName(website).addToggle(
        (toggle) => toggle.setValue(settings.enabledWebsites[website]).onChange(async (value) => {
          settings.enabledWebsites[website] = value;
          await this.plugin.saveSettings();
        })
      );
      AddPadding(websiteSetting, true);
    }
    new import_obsidian2.Setting(containerEl).setName("Google Docs").setHeading().setDesc('Note that when the view options is set to editable, the default page width is too small. Try to use "Preview" where possible');
    const googleDocsViewOptionDesc = new DocumentFragment();
    googleDocsViewOptionDesc.appendText("Preview - Uneditable, only embed the content");
    googleDocsViewOptionDesc.appendChild(createEl("br"));
    googleDocsViewOptionDesc.appendText("Edit minimal - Editable but don't show the header and toolbar");
    googleDocsViewOptionDesc.appendChild(createEl("br"));
    googleDocsViewOptionDesc.appendText("Edit default - Editable and shows the header and toolbar");
    const googleDocsOption = new import_obsidian2.Setting(containerEl).setName("Google Docs view options").setDesc(googleDocsViewOptionDesc).addDropdown((dropdown) => dropdown.addOptions(EnumToRecord(GoogleDocsViewOptions)).setValue(GoogleDocsViewOptions[settings.googleDocsViewOption]).onChange(async (value) => {
      settings.googleDocsViewOption = GoogleDocsViewOptions[value];
      await this.plugin.saveSettings();
    }));
    AddPadding(googleDocsOption, true);
    new import_obsidian2.Setting(containerEl).setName("Fallback link").setHeading().setDesc("Choose what the plugin does when the link isn't supported");
    const fallbackSettings = [];
    const fallbackEmbedSettings = [];
    function UpdateFallbackEmbedVisibility() {
      fallbackEmbedSettings.forEach((setting) => {
        setting.settingEl.style.display = settings.fallbackOptions === 1 /* EmbedLink */ ? "flex" : "none";
      });
    }
    fallbackSettings.push(new import_obsidian2.Setting(containerEl).setName("Fallback options").addDropdown((dropdown) => dropdown.addOptions(EnumToRecord(FallbackOptions)).setValue(FallbackOptions[settings.fallbackOptions]).onChange(async (value) => {
      settings.fallbackOptions = FallbackOptions[value];
      UpdateFallbackEmbedVisibility();
      await this.plugin.saveSettings();
    })));
    fallbackSettings.push(new import_obsidian2.Setting(containerEl).setName("Default width").setDesc("Default is 100%, filling the width of the viewport").addText(
      (text) => text.setValue(settings.fallbackWidth).setPlaceholder("100%").onChange(async (value) => {
        settings.fallbackWidth = value;
        await this.plugin.saveSettings();
      })
    ));
    fallbackSettings.push(new import_obsidian2.Setting(containerEl).setName("Default height").setDesc("Default is 500px. Set to 100vh if u want it to be the height of the viewport").addText(
      (text) => text.setValue(settings.fallbackHeight).setPlaceholder("500px").onChange(async (value) => {
        settings.fallbackHeight = value;
        await this.plugin.saveSettings();
      })
    ));
    fallbackEmbedSettings.push(
      new import_obsidian2.Setting(containerEl).setName("Auto link title").setDesc("Automatically fetches and displays the title below the embed when a custom title isn\u2019t set").addToggle(
        (toggle) => toggle.setValue(settings.fallbackAutoTitle).onChange(async (value) => {
          settings.fallbackAutoTitle = value;
          await this.plugin.saveSettings();
        })
      )
    );
    const defaultTitleDescription = new DocumentFragment();
    defaultTitleDescription.appendText("Default text when 'Auto link title' is false OR no title is found.");
    defaultTitleDescription.appendChild(createEl("br"));
    defaultTitleDescription.appendText("Set 'Auto link title' to false and clear 'Default title' to remove the link.");
    fallbackEmbedSettings.push(
      new import_obsidian2.Setting(containerEl).setName("Default title").setDesc(defaultTitleDescription).addText(
        (text) => text.setValue(settings.fallbackDefaultLink).setPlaceholder("Link").onChange(async (value) => {
          settings.fallbackDefaultLink = value;
          await this.plugin.saveSettings();
        })
      )
    );
    UpdateFallbackEmbedVisibility();
    fallbackSettings.push(...fallbackEmbedSettings);
    fallbackSettings.forEach((setting) => {
      AddPadding(setting);
    });
    const additionalInfo = new DocumentFragment();
    additionalInfo.appendText("All values and units use ");
    additionalInfo.appendChild(createEl("a", { text: "CSS Units", href: "https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#numbers_lengths_and_percentages" }));
    additionalInfo.appendChild(createEl("br"));
    additionalInfo.appendText("Reload any opened note to apply changes");
    additionalInfo.appendChild(createEl("br"));
    additionalInfo.appendChild(createEl("br"));
    additionalInfo.appendText("Found bugs, have a website to embed, or want a feature?");
    additionalInfo.appendChild(createEl("br"));
    additionalInfo.appendChild(createEl("a", { text: "Create a GitHub issue", href: "https://github.com/GnoxNahte/obsidian-auto-embed/issues/new" }));
    additionalInfo.appendText(" or ");
    additionalInfo.appendChild(createEl("a", { text: "submit a Google Form", href: "https://forms.gle/xtuv4FVCKZ2tg9zK9" }));
    new import_obsidian2.Setting(containerEl).setDesc(additionalInfo);
  }
  // TODO: Reload markdown after closing settings
  // hide() {
  // console.log("Hiding settings");
  // this.plugin.app.workspace.updateOptions();
  // }
};
function ResetEnabledWebsites() {
  return Object.fromEntries(
    supportedWebsites.map((website) => [
      website
      // Exclude some websites by default. Set the rest to true
      // (website !== "Twitter/X"),
    ])
  );
}

// src/suggestEmbed.ts
var import_obsidian3 = require("obsidian");
var Suggestion = class {
  constructor(choice) {
    this.choice = choice;
  }
};
Suggestion.embedLinkChoice = "Embed Link";
Suggestion.cancelChoice = "Cancel";
var SuggestEmbed = class extends import_obsidian3.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    if (!this.plugin.pasteInfo.trigger || !this.plugin.settings.suggestEmbed)
      return null;
    this.editor = editor;
    this.plugin.pasteInfo.trigger = false;
    return {
      start: cursor,
      end: cursor,
      query: this.plugin.pasteInfo.text
    };
  }
  getSuggestions(context) {
    return [new Suggestion(Suggestion.embedLinkChoice), new Suggestion(Suggestion.cancelChoice)];
  }
  renderSuggestion(suggestion, el) {
    el.setText(suggestion.choice);
  }
  selectSuggestion(suggestion, e) {
    const cursor = this.editor.getCursor();
    switch (suggestion.choice) {
      case Suggestion.embedLinkChoice:
        {
          const text = this.plugin.pasteInfo.text;
          this.plugin.markToEmbed(
            {
              text,
              start: {
                line: cursor.line,
                ch: cursor.ch - text.length
              },
              end: cursor
            },
            this.editor
          );
        }
        break;
      case Suggestion.cancelChoice:
        break;
      default:
        console.warn("Unknown suggestion - " + suggestion.choice + "?");
        break;
    }
    this.close();
  }
};

// src/utility.ts
var regexUrl = /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})/gi;
function isURL(str) {
  if (str.startsWith("app://")) {
    return false;
  }
  try {
    new URL(str);
    return true;
  } catch (e) {
    return false;
  }
}
function isLinkToImage(url) {
  return /\.(jpg|jpeg|png|webp|avif|gif)$/.test(url);
}

// src/embed-state-field.ts
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");

// src/embed-widget.ts
var import_view = require("@codemirror/view");
var EmbedWidget = class extends import_view.WidgetType {
  constructor(embedData, url, alt) {
    super();
    this.embedData = embedData;
    this.url = url;
    this.alt = alt;
  }
  toDOM(view) {
    const embedResult = this.embedData.embedSource.create(this.url, this.embedData);
    this.embedData.embedSource.applyModifications(embedResult, this.embedData);
    return embedResult.containerEl;
  }
  eq(other) {
    return this.url === other.url && (this.embedData.width === other.embedData.width && this.embedData.height === other.embedData.height) && this.alt === other.alt;
  }
};

// src/embeds/embedBase.ts
var import_obsidian4 = require("obsidian");
var BaseEmbedData = class {
  constructor(embedSource, originalString) {
    this.embedSource = embedSource;
    this.originalString = originalString;
    this.shouldEmbed = true;
  }
};
var EmbedBase = class {
  constructor(plugin) {
    this.autoEmbedCssClass = "auto-embed";
    this.plugin = plugin;
    this.sizeCache = {};
  }
  create(link, embedData) {
    const embed = this.createEmbed(link, embedData);
    let embedClass;
    if (embedData.embedSource.name === "Fallback")
      embedClass = "default-fallback-container";
    else if (embed.dataset.containerClass)
      embedClass = embed.dataset.containerClass;
    else
      embedClass = "auto-embed-unknown-class";
    const container = createDiv({ cls: ["auto-embed-container", embedClass] });
    container.appendChild(embed);
    (0, import_obsidian4.requestUrl)({ url: link, method: "HEAD" }).then((res) => {
      var _a;
      if (res.headers["content-type"].startsWith("image")) {
        container.classList.add("auto-embed-hide-display");
        (_a = container.parentElement) == null ? void 0 : _a.removeChild(container);
      }
    });
    if (embed.classList.contains("error-embed")) {
      console.log("Container: " + embedData.embedContainer);
      return {
        embedData,
        containerEl: container,
        embed
      };
    }
    const iframe = embed instanceof HTMLIFrameElement ? embed : embed.querySelector(":scope > iframe");
    let placeholder;
    const hideClass = "auto-embed-hide-visibility";
    function AddOnLoadEvent(iframe2) {
      function ShowEmbed_HidePlaceholder() {
        embed.classList.remove(hideClass);
        placeholder == null ? void 0 : placeholder.classList.add(hideClass);
      }
      iframe2 == null ? void 0 : iframe2.addEventListener("load", ShowEmbed_HidePlaceholder);
      container.addEventListener("auto-embed-error", ShowEmbed_HidePlaceholder);
    }
    if (this.plugin.settings.preloadOption !== 0 /* None */) {
      placeholder = this.generatePlaceholder(link);
      container.appendChild(placeholder);
      embed.classList.add(hideClass);
      if (this.plugin.settings.preloadOption === 2 /* Placeholder_ClickToLoad */) {
        iframe.dataset.src = iframe.src;
        iframe.src = "about:blank";
        placeholder.addEventListener("click", () => {
          placeholder == null ? void 0 : placeholder.classList.toggle("auto-embed-click-to-load", false);
          const loader = placeholder == null ? void 0 : placeholder.querySelector(".auto-embed-loader");
          if (loader)
            loader.classList.toggle(hideClass, false);
          const status = placeholder == null ? void 0 : placeholder.querySelector(".auto-embed-placeholder-status");
          if (status)
            status.textContent = "Loading embed...";
          if (!iframe.dataset.src) {
            console.error("iframe.dataset.src is not set");
            return;
          }
          iframe.src = iframe.dataset.src;
          AddOnLoadEvent(iframe);
        });
      } else {
        const loader = placeholder == null ? void 0 : placeholder.querySelector(".auto-embed-loader");
        if (loader)
          loader.classList.toggle(hideClass, false);
        AddOnLoadEvent(iframe);
      }
    }
    return {
      embedData,
      containerEl: container,
      embed,
      iframeEl: iframe != null ? iframe : void 0,
      placeholderEl: placeholder
    };
  }
  getOptions(alt) {
    const options = new BaseEmbedData(this, alt);
    if (!alt)
      return options;
    if (alt.match(/noembed/)) {
      options.shouldEmbed = false;
      return options;
    } else {
      options.shouldEmbed = true;
    }
    options.alt = alt;
    const widthMatch = alt.match(/(?:w|width)\s*(?::|=)\s*(\d+(?:%|\w+))/);
    if (widthMatch) {
      options.width = widthMatch[1];
      options.alt = options.alt.replace(widthMatch[0], "");
    }
    const heightMatch = alt.match(/(?:h|height)\s*(?::|=)\s*(\d+(?:%|\w+))/);
    if (heightMatch) {
      options.height = heightMatch[1];
      options.alt = options.alt.replace(heightMatch[0], "");
    }
    return options;
  }
  applyModifications(embedResult, data) {
    if (embedResult.iframeEl) {
      if (this.plugin.settings.preloadOption !== 2 /* Placeholder_ClickToLoad */)
        embedResult.iframeEl.setAttribute("loading", "lazy");
      embedResult.iframeEl.setAttribute("allowfullscreen", "true");
      embedResult.iframeEl.setAttribute("allowtransparency", "true");
    }
    if (data.width)
      embedResult.containerEl.style.width = data.width;
    if (data.height) {
      embedResult.containerEl.style.height = data.height;
    }
  }
  // For when the iframe is still loading
  generatePlaceholder(link) {
    const isClickToLoad = this.plugin.settings.preloadOption === 2 /* Placeholder_ClickToLoad */;
    const container = createDiv(
      {
        cls: `auto-embed-placeholder ${isClickToLoad ? "auto-embed-click-to-load" : ""}`,
        title: link
      }
    );
    createSpan(
      {
        parent: container,
        text: isClickToLoad ? "Click to load embed" : "Loading embed...",
        cls: "auto-embed-placeholder-status"
      }
    );
    createSpan({ cls: "auto-embed-loader auto-embed-hide-visibility", parent: container });
    createEl(
      "p",
      {
        parent: container,
        text: `Link: ${link}`,
        cls: "auto-embed-placeholder-link"
      }
    );
    return container;
  }
  resizeContainer(el, height, width) {
    if (height && el.parentElement)
      el.parentElement.style.height = height;
    if (width && el.parentElement)
      el.parentElement.style.width = width;
  }
  onErrorCreatingEmbed(url, msg) {
    const errorMsg = (msg != null ? msg : `Error with ${this.name} URL.`) + `
URL: ${url}`;
    const error = createEl("p", { cls: `${this.autoEmbedCssClass} error-embed` });
    error.setText(errorMsg);
    console.log("auto-embed/error: " + errorMsg);
    return error;
  }
};

// src/embeds/twitter.ts
var TwitterEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "Twitter/X";
    // Don't parse twitter since Obsidian already handles that.
    this.regex = new RegExp(/https:\/\/(?:x)\.com\/(\w+)(?:\/status\/(\w+))?/);
    this.embedOrigin = "https://platform.twitter.com";
  }
  createEmbed(url) {
    const regexMatch = url.match(this.regex);
    if (regexMatch === null)
      return this.onErrorCreatingEmbed(url);
    const iframe = createEl("iframe");
    const postId = regexMatch[2];
    const isPost = postId !== void 0;
    if (isPost)
      url = `https://platform.twitter.com/embed/Tweet.html?dnt=true&theme=${this.plugin.settings.darkMode ? "dark" : "light"}&id=${regexMatch[2]}`;
    else
      url = `https://syndication.twitter.com/srv/timeline-profile/screen-name/${regexMatch[1]}?dnt=true`;
    iframe.src = url;
    iframe.classList.add(this.autoEmbedCssClass);
    iframe.dataset.containerClass = "twitter-embed";
    iframe.sandbox.add("allow-forms", "allow-presentation", "allow-same-origin", "allow-scripts", "allow-modals", "allow-popups");
    if (isPost)
      iframe.setAttribute("scrolling", "no");
    iframe.dataset.twitterPostId = postId;
    if (this.sizeCache[postId] && this.sizeCache[postId].height) {
      iframe.style.height = this.sizeCache[postId].height + "px";
    }
    return iframe;
  }
  onResizeMessage(e) {
    if (e.data["twttr.embed"]["method"] !== "twttr.private.resize")
      return;
    const params = e.data["twttr.embed"]["params"][0];
    const postId = params["data"]["tweet_id"];
    const iframes = document.querySelectorAll(`.twitter-embed iframe[data-twitter-post-id="${postId}"]`);
    if (iframes.length === 0)
      return;
    for (let i = 0; i < iframes.length; ++i) {
      const iframe = iframes[i];
      const height = params["height"] + 1;
      iframe.style.height = height + "px";
      this.resizeContainer(iframe, iframe.style.height);
      if (postId)
        this.sizeCache[postId] = { width: 0, height };
    }
  }
};

// src/embeds/reddit.ts
var RedditEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "Reddit";
    this.regex = new RegExp(/reddit.com/);
    this.embedOrigin = "https://embed.reddit.com";
  }
  createEmbed(url) {
    const regexMatch = url.match(this.regex);
    if (regexMatch === null)
      return this.onErrorCreatingEmbed(url);
    const postIdRegexResult = url.match(/\/(?:comments|s)\/(\w+)/);
    if (!postIdRegexResult) {
      return this.onErrorCreatingEmbed(url, "Cannot find post id.");
    }
    const postId = postIdRegexResult[1];
    const iframe = createEl("iframe");
    iframe.classList.add(this.autoEmbedCssClass, "reddit-" + postId[1]);
    iframe.dataset.containerClass = "reddit-embed";
    url = url.replace("www.reddit.com", "embed.reddit.com");
    if (this.plugin.settings.darkMode) {
      url += (url.contains("?") ? "&" : "?") + "theme=dark";
    }
    iframe.src = url;
    iframe.setAttribute("scrolling", "no");
    iframe.setAttribute("allowfullscreen", "");
    iframe.dataset.redditPostId = postId;
    if (this.sizeCache[postId] && this.sizeCache[postId].height) {
      iframe.style.height = this.sizeCache[postId].height + "px";
    }
    return iframe;
  }
  onResizeMessage(e) {
    let data;
    try {
      data = JSON.parse(e.data);
    } catch (e2) {
      console.log("Error parsing reddit message. Error: " + e2);
      return;
    }
    if (data.type !== "resize.embed") {
      console.log("Reddit unknown message: " + data.type);
      return;
    }
    const iframes = document.querySelectorAll(".reddit-embed > iframe");
    console.log("Size: " + iframes.length);
    for (let i = 0; i < iframes.length; i++) {
      const iframe = iframes[i];
      if (iframe.contentWindow == e.source) {
        const height = data.data;
        iframe.style.height = height + "px";
        this.resizeContainer(iframe, iframe.style.height);
        const postId = iframe.dataset.redditPostId;
        if (postId)
          this.sizeCache[postId] = { width: 0, height };
        break;
      }
    }
  }
};

// src/embeds/steam.ts
var SteamEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "Steam";
    this.regex = new RegExp(/https:\/\/store\.steampowered\.com\/app\/(\d+)/);
  }
  createEmbed(url) {
    const regexMatch = url.match(this.regex);
    if (regexMatch === null)
      return this.onErrorCreatingEmbed(url);
    const iframe = createEl("iframe");
    iframe.src = `https://store.steampowered.com/widget/${regexMatch[1]}/`;
    iframe.classList.add(this.autoEmbedCssClass);
    iframe.dataset.containerClass = "steam-embed";
    return iframe;
  }
};

// src/embeds/codepen.ts
var CodepenEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "CodePen";
    this.regex = new RegExp(/https:\/\/codepen\.io\/([\w-]+)\/pen\/(\w+)(\?.*)?/);
  }
  createEmbed(url) {
    const regexMatch = url.match(this.regex);
    if (regexMatch === null)
      return this.onErrorCreatingEmbed(url);
    const iframe = createEl("iframe");
    iframe.src = `https://codepen.io/${regexMatch[1]}/embed/${regexMatch[2]}?default-tab=result&editable=true`;
    iframe.classList.add(this.autoEmbedCssClass);
    iframe.dataset.containerClass = "codepen-embed";
    return iframe;
  }
};

// src/embeds/spotify.ts
var SpotifyEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "Spotify";
    this.regex = new RegExp(/https:\/\/(?:open|play|www)\.spotify\.com\/(\w+)\/(\w+)(?:\?highlight=spotify:track:(\w+))?/);
  }
  createEmbed(url) {
    const regexMatch = url.match(this.regex);
    if (regexMatch === null)
      return this.onErrorCreatingEmbed(url);
    const container = createDiv();
    container.classList.add(this.autoEmbedCssClass);
    container.dataset.containerClass = "spotify-embed-container";
    if (regexMatch[1] === "playlist" || regexMatch[1] === "album" || regexMatch[1] === "artist")
      container.classList.add("spotify-playlist-embed");
    const iframe = createEl("iframe", { parent: container });
    iframe.src = `https://open.spotify.com/embed/${regexMatch[1]}/${regexMatch[2]}?utm_source=oembed` + (regexMatch[3] !== void 0 ? "&highlight=spotify:track:" + regexMatch[3] : "");
    iframe.classList.add(this.autoEmbedCssClass);
    iframe.setAttribute("allowfullscreen", "");
    iframe.setAttribute("allow", "autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture");
    return container;
  }
};

// src/embeds/imgur.ts
var ImgurEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "Imgur";
    this.regex = new RegExp(/https:\/\/imgur\.com\/(?:(?:a|gallery|(?:t\/\w+))\/)?(\w+)/);
    this.embedOrigin = "https://imgur.com";
  }
  createEmbed(url) {
    const regexMatch = url.match(this.regex);
    if (regexMatch === null)
      return this.onErrorCreatingEmbed(url);
    const imgurId = regexMatch[1];
    const iframe = createEl("iframe");
    iframe.src = `https://imgur.com/a/${imgurId}/embed?pub=true`;
    iframe.classList.add(this.autoEmbedCssClass);
    iframe.dataset.containerClass = "imgur-embed";
    iframe.dataset.imgurId = imgurId;
    if (this.sizeCache[imgurId] && this.sizeCache[imgurId].height) {
      iframe.style.height = this.sizeCache[imgurId].height + "px";
      if (this.sizeCache[imgurId].width)
        iframe.style.width = this.sizeCache[imgurId].width + "px";
    }
    iframe.setAttribute("scrolling", "no");
    return iframe;
  }
  onResizeMessage(e) {
    const data = JSON.parse(e.data);
    const href = data.href;
    const regexMatch = href.match(/https:\/\/imgur\.com\/(?:a\/)?(\w+)/);
    if (!regexMatch || regexMatch.length < 2)
      return;
    const imgurId = regexMatch[1];
    const iframes = document.querySelectorAll(`.imgur-embed iframe[data-imgur-id="${imgurId}"`);
    if (iframes.length === 0)
      return;
    for (let i = 0; i < iframes.length; ++i) {
      const iframe = iframes[i];
      if (data.message === "resize_imgur") {
        iframe.style.height = data.height + "px";
        iframe.style.width = data.width + "px";
        this.resizeContainer(iframe, iframe.style.height, iframe.style.width);
        this.sizeCache[imgurId] = { width: data.width, height: data.height };
      } else if (data.message === "404_imgur_embed") {
        iframe.src = iframe.src.replace("/a/", "/");
      }
    }
  }
};

// src/embeds/defaultFallbackEmbed.ts
var import_obsidian5 = require("obsidian");
var DefaultFallbackEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "Fallback";
    this.regex = new RegExp(/ /);
  }
  // Not using regex for this
  createEmbed(url, embedOptions) {
    switch (this.plugin.settings.fallbackOptions) {
      case 0 /* ShowErrorMessage */:
        return this.onErrorCreatingEmbed(url, "Website is not supported");
      case 1 /* EmbedLink */: {
        const embedContainer = createSpan();
        embedContainer.addClass(this.autoEmbedCssClass, "default-fallback-embed-container");
        const iframe = createEl("iframe");
        iframe.src = url;
        iframe.classList.add(this.autoEmbedCssClass);
        iframe.dataset.containerClass = "default-fallback-embed";
        if (embedOptions.width)
          embedContainer.style.width = embedOptions.width;
        else {
          const width = this.plugin.settings.fallbackWidth;
          if (width)
            embedContainer.style.width = width;
        }
        if (embedOptions.height)
          embedContainer.style.height = embedOptions.height;
        else {
          const height = this.plugin.settings.fallbackHeight;
          if (height)
            embedContainer.style.height = height;
        }
        embedContainer.appendChild(iframe);
        if (embedOptions.alt || this.plugin.settings.fallbackDefaultLink && !this.plugin.settings.fallbackAutoTitle) {
          const linkText = embedOptions.alt ? embedOptions.alt : this.plugin.settings.fallbackDefaultLink;
          const link = createEl("a", { href: url, text: linkText.trim() });
          embedContainer.appendChild(link);
        } else if (this.plugin.settings.fallbackAutoTitle) {
          const link = createEl("a", { href: url, text: "Loading title..." });
          this.linkTitle(url).then((title) => link.text = title);
          embedContainer.appendChild(link);
        }
        return embedContainer;
      }
      case 2 /* Hide */:
        return createEl("span", { cls: "auto-embed-hide-visibility" });
    }
  }
  async linkTitle(url) {
    try {
      const response = await (0, import_obsidian5.requestUrl)({ url, method: "GET" });
      console.log(response);
      if (!response.headers["content-type"].includes("text/html"))
        return this.plugin.settings.fallbackDefaultLink;
      const html = response.text;
      const doc = new DOMParser().parseFromString(html, "text/html");
      const title = doc.querySelector("title");
      if (title && title.text) {
        return title.text;
      } else {
        return this.plugin.settings.fallbackDefaultLink;
      }
    } catch (ex) {
      return `Error: ${ex.message}`;
    }
  }
};

// src/embeds/googleDocs.ts
var GoogleDocsEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "Google Docs";
    this.regex = new RegExp(/https:\/\/docs\.google\.com\/document\/d\/(\w+)/);
  }
  createEmbed(url) {
    const regexMatch = url.match(this.regex);
    if (regexMatch === null)
      return this.onErrorCreatingEmbed(url);
    const iframe = createEl("iframe");
    iframe.src = `https://docs.google.com/document/d/${regexMatch[1]}`;
    const viewOption = this.plugin.settings.googleDocsViewOption;
    switch (viewOption) {
      case 0 /* Preview */:
        iframe.src += "/preview";
        iframe.dataset.containerClass = "google-docs-embed-preview";
        break;
      case 1 /* EditMinimal */:
        iframe.src += "?rm=minimal";
        iframe.dataset.containerClass = "google-docs-embed-edit-minimal";
        break;
      case 2 /* EditDefault */:
      default:
        iframe.dataset.containerClass = "google-docs-embed-edit-default";
        break;
    }
    iframe.classList.add(this.autoEmbedCssClass);
    return iframe;
  }
};

// src/embeds/tiktok.ts
var TikTokEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "TikTok";
    this.embedOrigin = "https://www.tiktok.com";
    this.regex = new RegExp(/https:\/\/www\.tiktok\.com\/@([\w.]+)\/video\/(\d+)/);
  }
  createEmbed(url) {
    const regexMatch = url.match(this.regex);
    if (regexMatch === null)
      return this.onErrorCreatingEmbed(url);
    const iframe = createEl("iframe");
    const tiktokId = regexMatch[2];
    iframe.src = `https://www.tiktok.com/embed/v2/${tiktokId}/`;
    iframe.classList.add(this.autoEmbedCssClass);
    iframe.dataset.containerClass = "tiktok-embed";
    iframe.setAttribute("allowfullscreen", "");
    iframe.dataset.tiktokId = tiktokId;
    if (this.sizeCache[tiktokId] && this.sizeCache[tiktokId].height) {
      iframe.style.height = this.sizeCache[tiktokId].height + "px";
    }
    return iframe;
  }
  onResizeMessage(e) {
    if (e.data === "[tea-sdk]ready")
      return;
    let data;
    try {
      data = JSON.parse(e.data);
    } catch (error) {
      console.error("Cannot parse tiktok json:\n" + error);
      return;
    }
    const height = data.height;
    if (!height)
      return;
    const iframes = document.querySelectorAll(`.tiktok-embed iframe`);
    for (let i = 0; i < iframes.length; i++) {
      const iframe = iframes[i];
      if (iframe.contentWindow == e.source) {
        iframe.style.height = data.height + "px";
        this.resizeContainer(iframe, iframe.style.height);
        const tiktokId = iframe.dataset.tiktokId;
        if (tiktokId)
          this.sizeCache[tiktokId] = { width: 0, height };
        break;
      }
    }
  }
};

// src/embeds/soundcloud.ts
var SoundCloudEmbed = class extends EmbedBase {
  constructor() {
    super(...arguments);
    this.name = "SoundCloud";
    this.regex = new RegExp(/https:\/\/soundcloud\.com\/(.*)/);
  }
  createEmbed(url) {
    const regexMatch = url.match(this.regex);
    if (regexMatch === null)
      return this.onErrorCreatingEmbed(url);
    const iframe = createEl("iframe");
    iframe.src = `https://w.soundcloud.com/player/?url=https%3A//soundcloud.com/${regexMatch[1]}`;
    iframe.classList.add(this.autoEmbedCssClass);
    iframe.dataset.containerClass = "soundcloud-embed";
    return iframe;
  }
};

// src/embeds/embedManager.ts
var import_obsidian6 = require("obsidian");
var EmbedManager = class {
  constructor() {
  }
  static get Instance() {
    return this._instance || (this._instance = new this());
  }
  init(plugin) {
    this.plugin = plugin;
    this.embedSources = [
      // new YouTubeEmbed(plugin),
      new RedditEmbed(plugin),
      new SteamEmbed(plugin),
      new CodepenEmbed(plugin),
      new SpotifyEmbed(plugin),
      new ImgurEmbed(plugin),
      new GoogleDocsEmbed(plugin),
      new TikTokEmbed(plugin),
      new SoundCloudEmbed(plugin)
    ];
    this.ignoredDomains = [
      // Ignore embeds for youtube and twtiter
      new RegExp(/(?:https?:\/\/)?(?:www\.)?youtu(?:\.be\/|be.com\/)/)
    ];
    const apiVersionSplit = import_obsidian6.apiVersion.split(".");
    const majorVersion = parseInt(apiVersionSplit[0]);
    const minorVersion = parseInt(apiVersionSplit[1]);
    if (majorVersion > 1 || majorVersion === 1 && minorVersion >= 7) {
      this.ignoredDomains.push(new RegExp(/https:\/\/(?:twitter|x)\.com/));
    } else {
      this.embedSources.push(new TwitterEmbed(plugin));
      this.ignoredDomains.push(new RegExp(/https:\/\/(?:twitter)\.com/));
    }
    this.defaultFallbackEmbed = new DefaultFallbackEmbed(plugin);
  }
  // Gets the embed source for the url
  // Returns null if it can't / shouldn't be embedded.
  static getEmbedData(url, alt) {
    var _a;
    const domain = this._instance.ignoredDomains.find((domain2) => {
      return domain2.test(url);
    });
    if (domain) {
      return null;
    }
    const embedSource = (_a = this._instance.embedSources.find((source) => {
      return source.regex.test(url);
    })) != null ? _a : this._instance.defaultFallbackEmbed;
    const isWebsiteEnabled = !this._instance.plugin.settings.enabledWebsites[embedSource.name];
    if (embedSource !== this._instance.defaultFallbackEmbed && isWebsiteEnabled) {
      return null;
    }
    const options = embedSource.getOptions(alt);
    if (!options.shouldEmbed)
      return null;
    return options;
  }
};

// src/embed-state-field.ts
var import_obsidian7 = require("obsidian");
var formattingImageMarkerRegex = /formatting_formatting-image_image_image-marker(?:_list-\d*)?$/;
var stringUrlRegex = /^(?:list-\d*_)?string_url$/;
var embedField = import_state.StateField.define({
  create(state) {
    return import_view2.Decoration.none;
  },
  update(oldState, transaction) {
    const builder = new import_state.RangeSetBuilder();
    if (!transaction.state.field(import_obsidian7.editorLivePreviewField))
      return builder.finish();
    let altTextStartPos = null;
    (0, import_language.syntaxTree)(transaction.state).iterate({
      enter(node) {
        if (formattingImageMarkerRegex.test(node.type.name)) {
          altTextStartPos = node.to + 1;
        } else if (stringUrlRegex.test(node.type.name)) {
          if (altTextStartPos === null)
            return;
          const url = transaction.state.sliceDoc(node.from, node.to);
          const alt = altTextStartPos ? transaction.state.sliceDoc(altTextStartPos, node.from - 2) : "";
          altTextStartPos = null;
          if (!isURL(url) || isLinkToImage(url))
            return;
          const embedData = EmbedManager.getEmbedData(url, alt);
          if (embedData === null)
            return;
          const replaceFrom = node.to + 1;
          builder.add(
            replaceFrom,
            replaceFrom,
            import_view2.Decoration.replace({
              widget: new EmbedWidget(embedData, url, alt),
              block: true
            })
          );
        }
      }
    });
    return builder.finish();
  },
  provide(field) {
    return import_view2.EditorView.decorations.from(field);
  }
});

// src/main.ts
var PasteInfo = class {
  constructor(trigger, text) {
    this.trigger = trigger;
    this.text = text;
  }
};
var AutoEmbedPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.isShiftDown = false;
    this.pasteInfo = new PasteInfo(false, "");
  }
  async onload() {
    await this.loadSettings();
    const embedManager = EmbedManager.Instance;
    embedManager.init(this);
    this.registerEditorExtension(embedField);
    this.addSettingTab(new AutoEmbedSettingTab(this.app, this));
    this.registerDomEvent(document, "keydown", (e) => {
      if (e.shiftKey)
        this.isShiftDown = true;
    });
    this.registerDomEvent(document, "keydown", (e) => {
      if (!e.shiftKey)
        this.isShiftDown = false;
    });
    if (this.settings.suggestEmbed)
      this.registerSuggest();
    this.registerEvent(this.app.workspace.on("editor-paste", this.onPaste.bind(this)));
    this.registerMarkdownPostProcessor((el, ctx) => {
      const images = el.querySelectorAll("img");
      images.forEach((image) => {
        if (image.referrerPolicy !== "no-referrer" || !isURL(image.src) || isLinkToImage(image.src))
          return;
        this.handleImage(image);
      });
    });
    this.registerDomEvent(window, "message", (e) => {
      for (const source of EmbedManager.Instance.embedSources) {
        if (source.embedOrigin === e.origin && source.onResizeMessage) {
          source.onResizeMessage(e);
          break;
        }
      }
    });
    this.addCommand({
      id: "auto-embed-add-embed",
      name: "Add embed",
      editorCallback: (editor, ctx) => {
        const cursorPos = editor.getCursor();
        editor.replaceRange("![]()", cursorPos, cursorPos);
        cursorPos.ch += 4;
        editor.setCursor(cursorPos);
        return true;
      }
    });
    this.addCommand({
      id: "auto-embed-mark-to-embed",
      name: "Mark to embed",
      editorCheckCallback: (checking, editor, ctx) => {
        const selection = this.getLinkSelection(editor);
        if (checking)
          return selection !== null;
        if (selection) {
          editor.replaceRange(`![](${selection.text})`, selection.start, selection.end);
          const newCursorPos = selection.end;
          newCursorPos.ch += 4;
          editor.setCursor(newCursorPos);
        } else {
          console.error(`Command "Auto Embed: Mark to embed" is available even when there isn't any selection`);
        }
        return true;
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onPaste(e, editor) {
    var _a;
    if (e.defaultPrevented)
      return;
    if (this.isShiftDown)
      return;
    const clipboardData = (_a = e.clipboardData) == null ? void 0 : _a.getData("text/plain");
    if (!clipboardData || clipboardData === "" || !isURL(clipboardData))
      return;
    this.pasteInfo.trigger = true;
    this.pasteInfo.text = clipboardData;
  }
  // Creates the embed and replaces the Anchor element with it
  // Returns null if it's unable to convert it to an embed
  handleImage(img) {
    const alt = img.alt;
    const noEmbedRegex = /noembed/i;
    if (noEmbedRegex.test(alt)) {
      img.alt = alt.replace(noEmbedRegex, "");
      return null;
    }
    const src = img.src;
    const embedData = EmbedManager.getEmbedData(src, alt);
    if (embedData === null) {
      return null;
    }
    const embedResult = embedData.embedSource.create(src, embedData);
    embedData.embedSource.applyModifications(embedResult, embedData);
    const parent = img.parentElement;
    parent == null ? void 0 : parent.appendChild(embedResult.containerEl);
    img.classList.add("auto-embed-hide-display");
    img.addEventListener("load", () => {
      img.classList.remove("auto-embed-hide-display");
      embedResult.containerEl.classList.add("auto-embed-hide-display");
    });
    return embedResult.containerEl;
  }
  // // Replaces Obsidian's iframes for YouTube and Twitter. Makes it so the user can apply the same options
  // // TODO: Consider deleting if not replacing YouTube and Twitter
  // private handleIFrame(iframe: HTMLIFrameElement): HTMLElement | null { 
  // 	const src = iframe.src;
  // 	const embedSource = EmbedManager.getEmbedData(src, "");
  // 	if (embedSource === null) {
  // 		return null;
  // 	}
  // 	console.log("Found! : " + src);
  // 	const embed = embedSource.createEmbed(src);
  // 	// Insert embed
  // 	const parent = iframe.parentElement;
  // 	parent?.replaceChild(embed, iframe);
  // 	return embed;
  // }
  getSelection(editor) {
    if (!editor.somethingSelected())
      return null;
    return {
      start: editor.getCursor("from"),
      end: editor.getCursor("to"),
      text: editor.getSelection()
    };
  }
  // Used if there's nothing selected. Mostly when the user pastes a link
  getLinkSelection(editor) {
    const cursor = editor.getCursor();
    const lineText = editor.getLine(cursor.line);
    const matchedLinks = lineText.matchAll(regexUrl);
    for (const match of matchedLinks) {
      if (match.index && match.index <= cursor.ch && // Is start of match before cursor
      match.index + match[0].length >= cursor.ch) {
        return {
          start: {
            line: cursor.line,
            ch: match.index
          },
          end: {
            line: cursor.line,
            ch: match.index + match[0].length
          },
          text: match[0]
        };
      }
    }
    return null;
  }
  markToEmbed(selection, editor) {
    editor.replaceRange(`![](${selection.text})`, selection.start, selection.end);
  }
  registerSuggest() {
    this.registerEditorSuggest(new SuggestEmbed(this));
  }
};
